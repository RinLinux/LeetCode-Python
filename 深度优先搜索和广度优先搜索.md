# 深度优先搜索和广度优先搜索



DFS通用代码模板**递归写法**

```python
visited = set()
def dfs(node, visited):
    if node in visited: # terminator 
        # already visited     
        return     
    visited.add(node) 	
    # process current node here. 	...	
    for next_node in node.children():
        if next_node not in visited:
            dfs(next_node, visited)
```



非递归写法

```python
def DFS(self, root):
    if tree.root is None:
        return [] 
    visited, stack = [], [root]
    while stack:
        node = stack.pop()
        visited.add(node)
        process (node)
        # 生成相关的节点	
        nodes = generate_related_nodes(node)
        stack.push(nodes)
        # other processing work 
        # ...
```



BFS

```python
def BFS(root):
    visited = set()
    queue = [] 	
    queue.append([root])
    while queue:
        node = queue.pop()
        visited.add(node)		
        
        process(node)
        nodes = generate_related_nodes(node)
        queue.push(nodes)	
        
        # other processing work 
```





## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        res = []
        queue = [root]

        while queue:
            vals = []
            nxt = []
            for node in queue:
                vals.append(node.val)
                if node.left: nxt.append(node.left)
                if node.right: nxt.append(node.right)
            queue = nxt
            res.append(vals)
        return res
```





## [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)



给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**示例 1：**

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        res = []
        queue = [root]

        while queue:
            nxt = []
            vals = []

            for node in queue:
                vals.append(node.val)
                if node.left: nxt.append(node.left)
                if node.right: nxt.append(node.right)
            
            queue = nxt
            res.append(vals)
        
        return res[::-1]
```





## [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)



给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例 1：**

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        res = []
        queue = [root]


        even = False
        while queue:
            vals = []
            nxt = []
            for node in queue:
                vals.append(node.val)
                if node.left: nxt.append(node.left)
                if node.right: nxt.append(node.right)
            queue = nxt
            if even:vals = vals[::-1]
            res.append(vals)
            even = not even
        return res
```



## [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

 

**提示：**

- 树中节点数的范围在 `[0, 105]` 内
- `-1000 <= Node.val <= 1000`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0

        if not root.left and not root.right: return 1

        leftMindepth = self.minDepth(root.left)
        rightMindepth = self.minDepth(root.right)

        if root.left and  not root.right: return leftMindepth + 1
        if not root.left and root.right: return rightMindepth + 1

        return min(leftMindepth, rightMindepth) + 1
```





## [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 `'A'`、`'C'`、`'G'` 和 `'T'` 之一。

假设我们需要调查从基因序列 `start` 变为 `end` 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

- 例如，`"AACCGGTT" --> "AACCGGTA"` 就是一次基因变化。

另有一个基因库 `bank` 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 `bank` 中）

给你两个基因序列 `start` 和 `end` ，以及一个基因库 `bank` ，请你找出并返回能够使 `start` 变化为 `end` 所需的最少变化次数。如果无法完成此基因变化，返回 `-1` 。

注意：起始基因序列 `start` 默认是有效的，但是它并不一定会出现在基因库中。

 

**示例 1：**

```
输入：start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
输出：1
```

**示例 2：**

```
输入：start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
输出：2
```

**示例 3：**

```
输入：start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
输出：3
```

 

**提示：**

- `start.length == 8`
- `end.length == 8`
- `0 <= bank.length <= 10`
- `bank[i].length == 8`
- `start`、`end` 和 `bank[i]` 仅由字符 `['A', 'C', 'G', 'T']` 组成



```python
class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        CHARS = ['A','T','C','G']

        if startGene == endGene: return 0

        queue, bank = deque([(startGene,0)]), set(bank)

        while queue:
            cur, step = queue.popleft()
            for i, c in enumerate(cur):
                for char in CHARS:
                    if c != char and (ns := cur[:i] + char + cur[i+1:]) in bank:
                        if ns == endGene:
                            return step + 1
                        bank.remove(ns)
                        queue.append((ns,step+1))
        
        return -1
```







## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)



给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`



```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid: return 0

        row = len(grid)
        col = len(grid[0])

        res = 0

        def dfs(i, j):
            grid[i][j] = '0'

            for x, y in [[-1,0],[1,0],[0,-1],[0,1]]:
                dx = i + x
                dy = j + y
                if 0 <= dx < row and 0 <= dy < col and grid[dx][dy] == '1':
                    dfs(dx,dy)
        
        for i in range(row):
            for j in range(col):
                if grid[i][j] == '1':
                    dfs(i,j)
                    res += 1
        
        return res
        
```



## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 

**提示：**

- `1 <= n <= 8`



```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        m = n * 2
        res = []
        path = [''] * m

        def dfs(i, open):
            if i == m:
                res.append(''.join(path))
                return 
            if open < n:
                path[i] = '('
                dfs(i+1, open+1)
            if i - open < open:
                path[i] = ')'
                dfs(i+1, open)
        
        dfs(0,0)
        return res
```



## [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

**示例1：**

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
```

**示例2：**

```
输入: root = [1,2,3]
输出: [1,3]
```

 

**提示：**

- 二叉树的节点个数的范围是 `[0,104]`
- `-231 <= Node.val <= 231 - 1`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []

        queue, res = deque([root]), []

        while queue:
            cur = -inf
            for _  in range(len(queue)):
                node = queue.popleft()
                cur = max(cur, node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)

            res.append(cur)
        return res
```



## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)



给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`



```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid: return 0

        nr = len(grid)
        nc = len(grid[0])

        res = 0

        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    res += 1
                    queue = deque([(r,c)])
                    grid[r][c] = "0"

                    while queue:
                        row, col = queue.popleft()
                        for xrow, ycol in [(row-1,col),(row+1,col),(row,col-1),(row,col+1)]:
                            if 0 <= xrow < nr and  0 <= ycol < nc and grid[xrow][ycol] == "1":
                                queue.append((xrow,ycol))
                                grid[xrow][ycol] = "0"
        
        return res
```

